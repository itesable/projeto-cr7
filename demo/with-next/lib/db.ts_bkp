// lib/db.ts
import mysql from 'mysql2/promise';

interface ClaimRecord {
  id: number;
  username: string;
  address: string;
  hasClaimed: number;
  lastTimeClaimed: Date | null;
  totalClaimed: number;
  createdAt: Date;
  updatedAt: Date;
}

// Configura√ß√£o do banco de dados
const pool = mysql.createPool({
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0,
  timezone: 'utc' // Importante para evitar problemas com fuso hor√°rio
});

// Testar conex√£o com o banco de dados
async function testDatabaseConnection() {
  try {
    const connection = await pool.getConnection();
    console.log('‚úÖ Conex√£o com o banco de dados estabelecida com sucesso!');
    connection.release();
    
    // Verificar se a tabela existe
    const [tables]: any = await pool.query(
      "SHOW TABLES LIKE 'claims'"
    );
    
    if (tables.length === 0) {
      console.error('‚õî ATEN√á√ÉO: A tabela "claims" n√£o foi encontrada!');
      await initializeDatabase();
    } else {
      console.log('‚úÖ Tabela "claims" encontrada');
    }
  } catch (error) {
    console.error('‚õî Erro ao conectar ao banco de dados:', error);
    throw new Error('Falha na conex√£o com o banco de dados');
  }
}

// Criar tabela se n√£o existir
async function initializeDatabase() {
  const createTableQuery = `
    CREATE TABLE IF NOT EXISTS claims (
      id INT AUTO_INCREMENT PRIMARY KEY,
      username VARCHAR(255) NOT NULL,
      address VARCHAR(42) UNIQUE NOT NULL,
      hasClaimed TINYINT DEFAULT 0,
      lastTimeClaimed DATETIME NULL,
      totalClaimed INT DEFAULT 0,
      createdAt DATETIME DEFAULT CURRENT_TIMESTAMP,
      updatedAt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
  `;
  
  try {
    await pool.query(createTableQuery);
    console.log('‚úÖ Tabela claims criada/verificada com sucesso');
  } catch (error) {
    console.error('‚õî Erro ao criar tabela:', error);
    throw error;
  }
}

// Inicializar banco de dados e testar conex√£o
testDatabaseConnection()
  .then(() => initializeDatabase())
  .catch(err => console.error('‚õî Erro na inicializa√ß√£o do banco:', err));

// Fun√ß√µes de acesso ao banco de dados
export const db = {
  async getClaimRecord(address: string): Promise<ClaimRecord | null> {
    // Validar formato do endere√ßo
    if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
      console.error('‚õî Formato de endere√ßo inv√°lido:', address);
      return null;
    }
    
    try {
      console.log(`üîç Buscando registro para: ${address}`);
      const [rows]: any = await pool.query(
        'SELECT * FROM claims WHERE address = ?',
        [address]
      );
      
      if (rows.length > 0) {
        console.log('‚úÖ Registro encontrado:', rows[0]);
        return rows[0];
      }
      
      console.log('‚ÑπÔ∏è Nenhum registro encontrado para', address);
      return null;
    } catch (error) {
      console.error('‚õî Erro ao buscar registro:', error);
      throw error;
    }
  },

  async createOrUpdateClaimRecord(address: string, username: string) {
    // Validar inputs
    if (!address || !username) {
      throw new Error('Endere√ßo e username s√£o obrigat√≥rios');
    }
    
    try {
      const existingRecord = await this.getClaimRecord(address);
      
      if (existingRecord) {
        console.log('‚ÑπÔ∏è Registro j√° existe, retornando existente');
        return existingRecord;
      }
      
      console.log(`‚ûï Criando novo registro para: ${address} (${username})`);
      const [result]: any = await pool.query(
        'INSERT INTO claims (address, username) VALUES (?, ?)',
        [address, username]
      );
      
      console.log('‚úÖ Novo registro criado, ID:', result.insertId);
      return await this.getClaimRecord(address);
    } catch (error) {
      console.error('‚õî Erro ao criar/atualizar registro:', error);
      throw error;
    }
  },

  async updateClaimStatus(address: string) {
    try {
      console.log(`üîÑ Atualizando status para: ${address}`);
      const now = new Date();
      
      await pool.query(
        `UPDATE claims 
         SET hasClaimed = 1, 
             lastTimeClaimed = ?, 
             totalClaimed = totalClaimed + 1 
         WHERE address = ?`,
        [now, address]
      );
      
      console.log('‚úÖ Status atualizado com sucesso');
    } catch (error) {
      console.error('‚õî Erro ao atualizar status:', error);
      throw error;
    }
  },

  async canUserClaim(address: string): Promise<boolean> {
    // Validar endere√ßo
    if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
      console.error('‚õî Endere√ßo inv√°lido para verifica√ß√£o:', address);
      return false;
    }
    
    try {
      console.log(`‚ùì Verificando se pode claim: ${address}`);
      const record = await this.getClaimRecord(address);
      
      // Se n√£o h√° registro, pode fazer claim
      if (!record) {
        console.log('‚úÖ Pode claim: nenhum registro encontrado');
        return true;
      }
      
      // Se nunca fez claim, pode fazer
      if (record.hasClaimed === 0) {
        console.log('‚úÖ Pode claim: nunca fez claim antes');
        return true;
      }
      
      // Se h√° data do √∫ltimo claim, verificar intervalo
      if (record.lastTimeClaimed) {
        // Converter para Date se necess√°rio
        const lastClaimDate = record.lastTimeClaimed instanceof Date 
          ? record.lastTimeClaimed 
          : new Date(record.lastTimeClaimed);
        
        // Verificar se a data √© v√°lida
        if (isNaN(lastClaimDate.getTime())) {
          console.error('‚õî Data inv√°lida:', record.lastTimeClaimed);
          return true;
        }
        
        const now = new Date();
        const diffMs = now.getTime() - lastClaimDate.getTime();
        const diffHours = diffMs / (1000 * 60 * 60);
        
        console.log(`‚è±Ô∏è √öltimo claim: ${lastClaimDate}`);
        console.log(`‚è±Ô∏è Agora: ${now}`);
        console.log(`‚è±Ô∏è Diferen√ßa: ${diffHours.toFixed(2)} horas`);
        
        const canClaim = diffHours >= 24;
        console.log(`‚ÑπÔ∏è Pode claim: ${canClaim}`);
        return canClaim;
      }
      
      // Caso n√£o tenha data de √∫ltimo claim, permite
      console.log('‚úÖ Pode claim: sem data de √∫ltimo claim');
      return true;
    } catch (error) {
      console.error('‚õî Erro em canUserClaim:', error);
      return false;
    }
  },

  // Fun√ß√£o adicional para depura√ß√£o
  async getAllClaims() {
    try {
      const [rows]: any = await pool.query('SELECT * FROM claims');
      return rows;
    } catch (error) {
      console.error('‚õî Erro ao buscar todos os registros:', error);
      return [];
    }
  }
};
