'use client'

import { toast } from 'react-toastify';
import { createPublicClient, http, formatEther } from 'viem';
import { worldchain } from 'viem/chains';
import { ethers } from 'ethers';
import { useState, useEffect } from 'react';
import { MiniKit } from '@worldcoin/minikit-js';
import axios from 'axios';
import { SendTransaction } from '@/components/ClientContent/Transaction' 

// ABI do contrato intermediário
const Permit2UniswapBridgeABI = [
  {
    inputs: [
      {
        components: [
          {
            components: [
              { internalType: "address", name: "token", type: "address" },
              { internalType: "uint256", name: "amount", type: "uint256" },
            ],
            internalType: "struct IPermit2.TokenPermissions",
            name: "permitted",
            type: "tuple",
          },
          { internalType: "uint256", name: "nonce", type: "uint256" },
          { internalType: "uint256", name: "deadline", type: "uint256" },
        ],
        internalType: "struct IPermit2.PermitTransferFrom",
        name: "permit",
        type: "tuple",
      },
      { internalType: "bytes", name: "signature", type: "bytes" },
      { internalType: "uint256", name: "amountOutMin", type: "uint256" },
      { internalType: "address[]", name: "path", type: "address[]" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "deadline", type: "uint256" },
    ],
    name: "swapWithPermit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const;

// Endereços dos tokens na World Chain
const TOKENS = {
  USDC: '0x79A02482A880bCE3F13e09Da970dC34db4CD24d1',
  WLD: '0x2cFc85d8E48F8EAB294be644d9E25C3030863003',
  CR7: '0x3664c2D02e0DAcdBCbB90F839CAeaa7b925142d7',
};

// Contrato intermediário
const BRIDGE_CONTRACT = '0x32A17D6115b59900CC020B15a0183d1B81522736';

// Endereço do Permit2 (oficial)
const PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3';

// Endereço da fábrica da Uniswap V2
const UNISWAP_FACTORY_ADDRESS = '0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f';

// ABI da fábrica da Uniswap V2
const UNISWAP_FACTORY_ABI = [
  {
    constant: true,
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" },
    ],
    name: "getPair",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function",
  },
] as const;

// Configuração do cliente blockchain
const client = createPublicClient({
  chain: worldchain,
  transport: http('https://worldchain-mainnet.g.alchemy.com/public'),
});

interface UserProfile {
  username?: string;
  walletAddress?: string;
}

const SwapInterface = () => {
  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);
  const [userAddress, setUserAddress] = useState<string>('');
  const [tokenBalances, setTokenBalances] = useState<Record<string, string>>({});
  const [gasBalance, setGasBalance] = useState<string>('0');
  const [loading, setLoading] = useState<boolean>(true);
  const [swapStatus, setSwapStatus] = useState<string>('');
  const [tenderlyUrl, setTenderlyUrl] = useState<string>('');
  const [inputAmount, setInputAmount] = useState<string>('0.1');
  const [fromToken, setFromToken] = useState<string>(TOKENS.USDC);
  const [toToken, setToToken] = useState<string>(TOKENS.WLD);

  // Efeito para carregar o perfil do usuário
  useEffect(() => {
    const storedProfile = localStorage.getItem('userProfile');
    if (storedProfile) {
      const profile = JSON.parse(storedProfile);
      setUserProfile(profile);
      if (profile.walletAddress) setUserAddress(profile.walletAddress);
      else if (profile.username) fetchUserAddress(profile.username);
    }
  }, []);

  // Carregar saldos quando o endereço mudar
  useEffect(() => {
    if (userAddress) loadBalances();
  }, [userAddress]);

  // Buscar endereço associado ao username
  const fetchUserAddress = async (username: string) => {
    try {
      const response = await axios.get(
        `https://usernames.worldcoin.org/api/v1/search/${username}`
      );
      const userData = response.data.find(
        (user: any) => user.username === username
      );
      if (userData) {
        setUserAddress(userData.address);
        const updatedProfile = { ...userProfile!, walletAddress: userData.address };
        setUserProfile(updatedProfile);
        localStorage.setItem('userProfile', JSON.stringify(updatedProfile));
      }
    } catch (error) {
      console.error("Erro ao buscar endereço:", error);
      setSwapStatus("Não foi possível buscar o endereço da carteira.");
    }
  };

  // Verificar saldo de token
  const checkBalance = async (tokenAddress: string, ownerAddress: string): Promise<bigint> => {
    const erc20ABI = [
      {
        constant: true,
        inputs: [{ name: "_owner", type: "address" }],
        name: "balanceOf",
        outputs: [{ name: "balance", type: "uint256" }],
        type: "function"
      }
    ] as const;

    return client.readContract({
      address: tokenAddress as `0x${string}`,
      abi: erc20ABI,
      functionName: 'balanceOf',
      args: [ownerAddress as `0x${string}`]
    });
  };

  // Verificar saldo de ETH
  const checkGasBalance = async (): Promise<bigint> => {
    if (!userAddress) return BigInt(0);
    try {
      return await client.getBalance({ address: userAddress as `0x${string}` });
    } catch (error) {
      console.error('Erro ao verificar saldo de ETH:', error);
      setSwapStatus('Falha ao verificar saldo de rede');
      return BigInt(0);
    }
  };

  // Carregar todos os saldos
  const loadBalances = async () => {
    if (!userAddress) return;
    setLoading(true);
    try {
      const ethBalance = await checkGasBalance();
      setGasBalance(formatEther(ethBalance));
      
      const balances: Record<string, string> = {};
      for (const [tokenName, tokenAddress] of Object.entries(TOKENS)) {
        const balance = await checkBalance(tokenAddress, userAddress);
        balances[tokenName] = ethers.formatUnits(balance, tokenName === 'USDC' ? 6 : 18);
      }
      setTokenBalances(balances);
    } catch (error) {
      console.error('Erro ao carregar saldos:', error);
      setSwapStatus('Falha ao carregar saldos');
    } finally {
      setLoading(false);
    }
  };

  // Verificar configuração do contrato
  const checkBridgeConfig = async () => {
    try {
      const bridgeABI = [
        {
          inputs: [],
          name: "permit2",
          outputs: [{ internalType: "address", name: "", type: "address" }],
          stateMutability: "view",
          type: "function"
        },
        {
          inputs: [],
          name: "uniswapRouter",
          outputs: [{ internalType: "address", name: "", type: "address" }],
          stateMutability: "view",
          type: "function"
        }
      ] as const;
      
      const permit2Address = await client.readContract({
        address: BRIDGE_CONTRACT as `0x${string}`,
        abi: bridgeABI,
        functionName: 'permit2'
      });
      
      const uniswapRouterAddress = await client.readContract({
        address: BRIDGE_CONTRACT as `0x${string}`,
        abi: bridgeABI,
        functionName: 'uniswapRouter'
      });
      
      return { permit2Address, uniswapRouterAddress };
    } catch (error) {
      console.error("Erro ao verificar configuração:", error);
      return null;
    }
  };

  // Verificar permissão no Permit2
  const checkPermit2Allowance = async (owner: string, token: string, spender: string) => {
    try {
      const permit2ABI = [
        {
          inputs: [
            { internalType: "address", name: "user", type: "address" },
            { internalType: "address", name: "token", type: "address" },
            { internalType: "address", name: "spender", type: "address" }
          ],
          name: "allowance",
          outputs: [
            { internalType: "uint160", name: "amount", type: "uint160" },
            { internalType: "uint48", name: "expiration", type: "uint48" },
            { internalType: "uint48", name: "nonce", type: "uint48" }
          ],
          stateMutability: "view",
          type: "function"
        }
      ] as const;
      
      return client.readContract({
        address: PERMIT2_ADDRESS as `0x${string}`,
        abi: permit2ABI,
        functionName: 'allowance',
        args: [owner as `0x${string}`, token as `0x${string}`, spender as `0x${string}`]
      });
    } catch (error) {
      console.error("Erro ao verificar permissão Permit2:", error);
      return null;
    }
  };

  // Aprovar token no Permit2
  const approveTokenForPermit2 = async () => {
    setSwapStatus('Solicitando aprovação...');
    try {
      const { finalPayload } = await MiniKit.commandsAsync.sendTransaction({
        transaction: [
          {
            address: fromToken as `0x${string}`,
            abi: [
              {
                inputs: [
                  { name: "spender", type: "address" },
                  { name: "value", type: "uint256" }
                ],
                name: "approve",
                outputs: [{ name: "", type: "bool" }],
                stateMutability: "nonpayable",
                type: "function"
              }
            ],
            functionName: 'approve',
            args: [PERMIT2_ADDRESS, ethers.MaxUint256]
          },
        ]
      });
      
      setSwapStatus('Aprovação em andamento...');
      
      if (finalPayload.status === 'error') {
        let errorDetails = `Código: ${finalPayload.error_code}`;
        
        // Tratamento específico para disallowed_operation
        if (finalPayload.error_code.includes("disallowed_operation")) {
          errorDetails = "Operação não permitida pela carteira";
          console.error("Operação bloqueada pela carteira:", finalPayload);
        }
        
        if (finalPayload.simulation_id) {
          errorDetails += ` | Simulation ID: ${finalPayload.simulation_id}`;
          setTenderlyUrl(`https://dashboard.tenderly.co/public/worldcoin/world-chain/simulator/${finalPayload.simulation_id}`);
        }
        
        setSwapStatus(`Falha na aprovação: ${errorDetails}`);
        return false;
      }
      return true;
    } catch (error) {
      console.error('Erro na aprovação:', error);
      setSwapStatus('Falha na aprovação');
      return false;
    }
  };

  // Validar par de tokens
  const validatePair = async (tokenA: string, tokenB: string) => {
    try {
      const pairAddress = await client.readContract({
        address: UNISWAP_FACTORY_ADDRESS as `0x${string}`,
        abi: UNISWAP_FACTORY_ABI,
        functionName: 'getPair',
        args: [tokenA as `0x${string}`, tokenB as `0x${string}`]
      });
      return pairAddress !== '0x0000000000000000000000000000000000000000';
    } catch (error) {
      console.error('Erro ao validar par:', error);
      return false;
    }
  };

  // Estimar gás da transação
  const estimateGas = async (args: any[]) => {
    try {
      return await client.estimateContractGas({
        address: BRIDGE_CONTRACT as `0x${string}`,
        abi: Permit2UniswapBridgeABI,
        functionName: 'swapWithPermit',
        args: args,
        account: userAddress as `0x${string}`
      });
    } catch (error) {
      console.error('Erro ao estimar gás:', error);
      return null;
    }
  };

  // Executar swap
  const executeSwap = async () => {
    if (!userAddress) {
      setSwapStatus('Endereço do usuário não disponível');
      console.error('Endereço do usuário não disponível');
      return;
    }
    
    if (parseFloat(inputAmount) <= 0) {
      setSwapStatus('Quantidade inválida');
      console.error('Quantidade inválida');
      return;
    }
    
    // Converter quantidade para unidades mínimas
    const decimals = fromToken === TOKENS.USDC ? 6 : 18;
    const amountIn = ethers.parseUnits(inputAmount, decimals);
    
    // Verificar saldo
    const userBalance = await checkBalance(fromToken, userAddress);
    if (userBalance < amountIn) {
      setSwapStatus('Saldo insuficiente');
      console.error('Saldo insuficiente');
      return;
    }
    
    // Verificar configuração do contrato
    setSwapStatus('Verificando configuração...');
    const bridgeConfig = await checkBridgeConfig();
    if (!bridgeConfig) {
      setSwapStatus('Falha ao verificar configuração da bridge');
      console.error('Falha ao verificar configuração da bridge');
      return;
    }
    
    // Verificar permissão no Permit2
    setSwapStatus('Verificando permissões...');
    const allowance = await checkPermit2Allowance(userAddress, fromToken, BRIDGE_CONTRACT);
    if (!allowance) {
      setSwapStatus('Falha ao verificar permissões');
      console.error('Falha ao verificar permissões');
      return;
    }
    
    // Se permissão insuficiente, solicitar aprovação
    if (BigInt(allowance[0]) < amountIn) {
      setSwapStatus('Permissão insuficiente. Solicitando aprovação...');
      const approved = await approveTokenForPermit2();
      if (!approved) return;
      
      // Aguardar blockchain atualizar
      await new Promise(resolve => setTimeout(resolve, 15000));
      
      // Verificar novamente a permissão
      const newAllowance = await checkPermit2Allowance(userAddress, fromToken, BRIDGE_CONTRACT);
      if (!newAllowance || BigInt(newAllowance[0]) < amountIn) {
        setSwapStatus('Aprovação insuficiente mesmo após aprovação');
        console.error('Aprovação insuficiente mesmo após aprovação');
        return;
      }
    }
    
    // Validar par de tokens
    setSwapStatus('Validando par de tokens...');
    const isValidPair = await validatePair(fromToken, toToken);
    if (!isValidPair) {
      setSwapStatus('Par de tokens inválido para swap');
      console.error('Par de tokens inválido para swap');
      return;
    }
    
    // Configurar parâmetros do swap
    const deadline = Math.floor((Date.now() + 30 * 60 * 1000) / 1000);
    const path = [fromToken, toToken];
    const nonce = allowance[2]; // Usar nonce do Permit2
    
    // Estrutura de permissão do Permit2
    const permitTransfer = {
      permitted: {
        token: fromToken,
        amount: amountIn,
      },
      nonce: nonce,
      deadline: BigInt(deadline),
    };

    try {
      setSwapStatus('Preparando transação...');
      
      // Argumentos para a transação
      const txArgs = [
        permitTransfer,
        "0x", // signature será preenchida
        BigInt(0), // amountOutMin
        path,
        userAddress,
        BigInt(deadline)
      ];
      
      // Estimar gás
      const gasEstimate = await estimateGas(txArgs);
      if (!gasEstimate) {
        setSwapStatus('Falha ao estimar gás da transação');
        console.error('Falha ao estimar gás da transação');
        return;
      }
      
      const { finalPayload } = await MiniKit.commandsAsync.sendTransaction({
        transaction: [
          {
            address: BRIDGE_CONTRACT as `0x${string}`,
            abi: Permit2UniswapBridgeABI,
            functionName: 'swapWithPermit',
            args: txArgs,
            gas: gasEstimate * BigInt(12) / BigInt(10) // 20% a mais
          },
        ],
        permit2: [
          {
            ...permitTransfer,
            spender: BRIDGE_CONTRACT,
            permitted: {
              token: fromToken,
              amount: amountIn.toString(),
            },
            nonce: nonce.toString(),
            deadline: deadline.toString()
          },
        ],
      });
      
      // Tratar erros na simulação
      if (finalPayload.status === 'error') {
        let errorDetails = `Código: ${finalPayload.error_code}`;
        
        // Tratamento específico para disallowed_operation
        if (finalPayload.error_code.includes("disallowed_operation")) {
          errorDetails = "Operação não permitida pela carteira";
          console.error("Operação bloqueada pela carteira:", {
            error: finalPayload,
            txArgs,
            permitTransfer
          });
        }
        // Outros tratamentos de erro
        else if (finalPayload.error_code.includes("INSUFFICIENT")) {
          errorDetails = "Saldo insuficiente para realizar o swap";
        } else if (finalPayload.error_code.includes("DEADLINE")) {
          errorDetails = "Prazo expirado, tente novamente";
        } else if (finalPayload.error_code.includes("INVALID_SIGNATURE")) {
          errorDetails = "Assinatura inválida";
        }
        
        setSwapStatus(`Falha na transação: ${errorDetails}`);
        console.error('Erro na transação:', finalPayload);
        return;
      }
      
      // Sucesso
      setSwapStatus('Swap realizado com sucesso!');
      toast.success('Swap realizado com sucesso');
      
      // Atualizar saldos após o swap
      setTimeout(loadBalances, 15000);
    } catch (error) {
      console.error('Erro ao executar swap:', error);
      setSwapStatus('Falha ao executar swap');
    }
  };

  // Função para formatar saldo
  const formatBalance = (balance: string) => {
    return parseFloat(balance).toFixed(4);
  };

  return (
    <div className="max-w-md mx-auto p-6 bg-white rounded-lg shadow-md">
      <h2 className="text-2xl font-bold mb-6 text-center">Swap de Tokens</h2>
      
      {/* Seção de saldos */}
      <div className="mb-6 p-4 bg-gray-50 rounded-lg">
        <h3 className="font-semibold mb-2">Saldos:</h3>
        <div className="grid grid-cols-2 gap-2">
          <div className="flex justify-between">
            <span>ETH:</span>
            <span className="font-mono">{loading ? '...' : formatBalance(gasBalance)}</span>
          </div>
          {Object.entries(TOKENS).map(([tokenName]) => (
            <div key={tokenName} className="flex justify-between">
              <span>{tokenName}:</span>
              <span className="font-mono">
                {loading ? '...' : tokenBalances[tokenName] ? formatBalance(tokenBalances[tokenName]) : '0.0000'}
              </span>
            </div>
          ))}
        </div>
      </div>
      
      < SendTransaction />
      
      {/* Interface de swap */}
      <div className="mb-4">
        <div className="flex items-center mb-4">
          <div className="flex-1 mr-2">
            <label className="block text-sm font-medium mb-1">De:</label>
            <select
              className="w-full p-2 border rounded"
              value={fromToken}
              onChange={(e) => setFromToken(e.target.value)}
            >
              <option value={TOKENS.USDC}>USDC</option>
              <option value={TOKENS.WLD}>WLD</option>
              <option value={TOKENS.CR7}>CR7</option>
            </select>
          </div>
          
          <div className="flex-1 ml-2">
            <label className="block text-sm font-medium mb-1">Quantia:</label>
            <input
              type="number"
              className="w-full p-2 border rounded"
              value={inputAmount}
              onChange={(e) => setInputAmount(e.target.value)}
              min="0"
              step="0.1"
            />
          </div>
        </div>
        
        <div className="flex items-center mb-4">
          <div className="flex-1 mr-2">
            <label className="block text-sm font-medium mb-1">Para:</label>
            <select
              className="w-full p-2 border rounded"
              value={toToken}
              onChange={(e) => setToToken(e.target.value)}
            >
              <option value={TOKENS.WLD}>WLD</option>
              <option value={TOKENS.USDC}>USDC</option>
              <option value={TOKENS.CR7}>CR7</option>
            </select>
          </div>
          
          <div className="flex-1 ml-2">
            <label className="block text-sm font-medium mb-1">Receberá ≈</label>
            <div className="w-full p-2 border rounded bg-gray-50">
              {parseFloat(inputAmount).toFixed(4)}
            </div>
          </div>
        </div>
      </div>
      
      {/* Botão de swap */}
      <button
        onClick={executeSwap}
        disabled={loading}
        className={`w-full py-3 px-4 rounded-md text-white font-medium ${
          loading ? 'bg-gray-400' : 'bg-blue-600 hover:bg-blue-700'
        }`}
      >
        {loading ? 'Carregando...' : 'Fazer Swap'}
      </button>
      
      {/* Status do swap */}
      {swapStatus && (
        <div className="mt-4 p-3 bg-blue-50 rounded-md">
          <p className="text-sm text-blue-700">{swapStatus}</p>
        </div>
      )}
      
      {/* Link para debug no Tenderly */}
      {tenderlyUrl && (
        <div className="mt-4">
          <a
            href={tenderlyUrl}
            target="_blank"
            rel="noopener noreferrer"
            className="text-blue-600 hover:underline text-sm"
          >
            Depurar transação no Tenderly
          </a>
        </div>
      )}
    </div>
  );
};

export default SwapInterface;
